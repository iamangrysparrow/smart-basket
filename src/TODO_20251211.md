# TODO 2025-12-11

## 1. Рефакторинг архитектуры парсинга чеков

**Проблема**: Текущая архитектура игнорирует настройку `Parser` в `ReceiptSource`. Вместо этого `ReceiptTextParserFactory` перебирает все парсеры методом `CanParse()`.

**Правильная архитектура**:
```
ReceiptSource (настройки)
    │
    ├── Parser: "InstamartParser" / "LlmUniversalParser" / "Auto"
    │
    ↓
ReceiptParsingService.ParseReceiptAsync(body, date, parserName, ...)
    │
    ├── parserName = "Auto" → используем "LlmUniversalParser"
    │
    ├── GetParser(parserName) → IReceiptTextParser
    │       ├── "InstamartParser" → InstamartParser
    │       └── "LlmUniversalParser" → LlmUniversalParser
    │
    ├── parser.Parse(body, date)
    │       ├── Success → return result
    │       └── Error → Log ошибку + fallback на LlmUniversalParser (если ещё не он)
    │
    └── return result
```

**Изменения**:
- [x] `LlmUniversalParser : IReceiptTextParser` - новый класс с LLM логикой
- [x] `ReceiptTextParserFactory` - метод `GetParser(name)` и `GetParserOrDefault(name)`
- [x] `ReceiptCollectionService` - использует парсер по имени из `source.ParserName`, fallback на LLM
- [x] DI регистрация `LlmUniversalParser`
- [x] `IReceiptTextParser.CanParse()` - оставлен для UI и auto-detect
- [ ] `IReceiptParsingService` - legacy, может быть удалён (используется только в старом flow MainViewModel)

---

## 2. Batch-назначение меток (Labels)

**Проблема**: Сейчас `LabelAssignmentService` вызывается для каждого товара отдельно. Это неэффективно - много вызовов LLM.

**Решение**: Использовать batch-режим для всего чека за 1 вызов LLM.

- Меток обычно ~10
- Чек обычно до 100 позиций
- Даже слабая LLM справится за 1 проход

**Изменения**:
- [ ] Использовать `AssignLabelsBatchAsync` вместо цикла по товарам
- [ ] Проверить что batch-метод работает корректно

---

## 3. Улучшение Application Log

**Проблемы**:
- Нельзя скопировать текст из лога
- Экран постоянно "трясется" (auto-scroll мешает)
- Неудобно читать при большом количестве сообщений

**Решение**:
- [ ] Сделать лог копируемым (TextBox вместо ListBox? или SelectionMode)
- [ ] Добавить кнопку "Pause auto-scroll" или остановка при ручной прокрутке
- [ ] Возможно: добавить кнопку "Copy all" для копирования всего лога
- [ ] Возможно: уровни логирования (DEBUG/INFO/WARN/ERROR) с фильтрацией

---

## 4. Метки не назначаются на Products и Items

**Проблема**: После парсинга и классификации метки не сохраняются в БД.

**Проверить**:
- [ ] Вызывается ли `LabelAssignmentService` после классификации?
- [ ] Сохраняются ли `ProductLabel` и `ItemLabel` в БД?
- [ ] Есть ли user_labels.txt с доступными метками?

---

## 5. Подключение кастомного Yandex агента

**Задача**: Интеграция с кастомным Yandex-агентом (YandexGPT с кастомным промптом/агентом).

**Изменения**:
- [ ] Изучить API кастомных агентов Yandex
- [ ] Расширить `AiProviderType` enum (если нужен отдельный тип)
- [ ] Реализовать поддержку в `YandexGptLlmProvider` или создать новый провайдер
- [ ] Добавить настройки в `AiProviderConfig` (agent_id, etc.)
- [ ] Протестировать интеграцию

---

## Выполнено сегодня

- [x] Убрана вкладка Settings из MainWindow (теперь отдельное окно)
- [x] Рефакторинг CLI на новую архитектуру (AiProviders, ReceiptSources)
- [x] Удалён мёртвый код: `ICategoryService`, `CategoryService`, `LlmProviderFactory`
- [x] Все сервисы переведены на `IAiProviderFactory`:
  - `ProductClassificationService`
  - `LabelAssignmentService`
  - `ReceiptParsingService`
- [x] Добавлено детальное логирование с проверкой на null-провайдер
- [x] Исправлены все warnings (0 warnings, 0 errors)
- [x] **Рефакторинг архитектуры парсинга (TODO #1)**:
  - Создан `LlmUniversalParser : IReceiptTextParser` — универсальный LLM парсер
  - `ReceiptTextParserFactory` — добавлены методы `GetParser(name)`, `GetParserOrDefault(name)`, `TryParseWithRegex()`
  - `ReceiptCollectionService` — теперь использует парсер из `source.ParserName` с fallback на LLM
  - Убрана зависимость `ReceiptCollectionService` от `IReceiptParsingService`
